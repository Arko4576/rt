#!@PERL@
# BEGIN BPS TAGGED BLOCK {{{
#
# COPYRIGHT:
#
# This software is Copyright (c) 1996-2017 Best Practical Solutions, LLC
#                                          <sales@bestpractical.com>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to Best Practical Solutions, LLC.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# Request Tracker, to Best Practical Solutions, LLC, you confirm that
# you are the copyright holder for those contributions and you grant
# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# END BPS TAGGED BLOCK }}}
use 5.010;
use strict;
use warnings;

# fix lib paths, some may be relative
BEGIN {
    require File::Spec;
    my @libs = ("@RT_LIB_PATH@", "@LOCAL_LIB_PATH@");
    my $bin_path;

    for my $lib (@libs) {
        unless ( File::Spec->file_name_is_absolute($lib) ) {
            unless ($bin_path) {
                if ( File::Spec->file_name_is_absolute(__FILE__) ) {
                    $bin_path = ( File::Spec->splitpath(__FILE__) )[1];
                }
                else {
                    require FindBin;
                    no warnings "once";
                    $bin_path = $FindBin::Bin;
                }
            }
            $lib = File::Spec->catfile( $bin_path, File::Spec->updir, $lib );
        }
        unshift @INC, $lib;
    }

}

use RT;
RT::LoadConfig();
RT::Init();

use List::MoreUtils 'uniq';
use JSON ();
my $JSON = JSON->new->canonical;

die "usage: $0 base edited\n" unless @ARGV == 2;
my ($base_file, $edited_file) = @ARGV;

my $base_records = slurp_json($base_file);
my $edited_records = slurp_json($edited_file);

my $export_options = delete $edited_records->{ExportOptions}
    or die "Required metadata ExportOptions not present in $edited_file. Did you pass --sync to rt-serializer?";
delete $base_records->{ExportOptions};

my @record_types = qw/Groups Users Members ACL Queues Classes
                      ScripActions ScripConditions Templates
                      CustomFields CustomRoles Scrips
                      Catalogs Assets Articles/;

my %class_type = (
    Members => 'GroupMembers',
);

for my $type (@record_types) {
    my ($new_records, $updated_records, $deleted_records) = find_differences(
        $base_records->{$type},
        $edited_records->{$type},
        $type,
    );

    my $collection_class = "RT::" . ($class_type{$type} || $type);
    my $record_class = $collection_class->RecordClass;

    for (@$updated_records) {
        my ($base, $edited) = @$_;
        my $id = $base->{id};
        my $record = $record_class->new(RT->SystemUser);
        $record->Load($id);
        if (!$record->Id) {
            RT->Logger->error("Unable to load $record_class $id for updating; skipping");
            next;
        }

        for my $column (uniq sort keys(%$base), keys(%$edited)) {
            my $base_value = $base->{$column} // "";
            my $edited_value = $edited->{$column} // "";

            for ($base_value, $edited_value) {
                $_ = !!$_ if JSON::is_bool($_)
            }

            next if is_deeply_equal($base_value, $edited_value);

            if (!ref($base_value) && !ref($edited_value)) {
                my $method = "Set$column";
                if ($record->can($method) || $record->_Accessible($column, 'write')) {
                    my ($ok, $msg) = $record->$method($edited_value);
                    if ($ok) {
                        RT->Logger->debug("Updated $record_class #$id $column: $msg");
                    }
                    else {
                        RT->Logger->error("Unable to update $record_class #$id $column: $msg");
                    }
                }
                else {
                    die "Unable to handle updating $record_class $column (no method)";
                }
            }
            else {
                die "Unable to handle updating $record_class $column (composite value)";
            }
        }
    }

    for my $new (@$new_records) {
        my $record = $record_class->new(RT->SystemUser);
    }

    for my $deleted (@$deleted_records) {
        my $id = $deleted->{id};
        my $record = $record_class->new(RT->SystemUser);
        $record->Load($id);

        my ($ok, $msg);
        if ($record->can('SetDisabled') || $record->_Accessible('Disabled', 'write')) {
            ($ok, $msg) = $record->SetDisabled(1);
        }
        elsif ($record->can('Delete')) {
            ($ok, $msg) = $record->Delete;
        }
        else {
            die "No method to delete $record_class #$id";
        }

        if ($ok) {
            RT->Logger->debug("Deleted $record_class #$id: $msg");
        }
        else {
            RT->Logger->error("Unable to delete $record_class #$id: $msg");
        }
    }
}

sub find_differences {
    my $base_records = shift;
    my $edited_records = shift;
    my $type = shift;

    my (@new, @deleted, @updated);
    my (%base_by_id, %edited_by_id);

    for my $base_record (@$base_records) {
        my $id = $base_record->{id};

        if (!$id) {
            die "Missing id for this $type record in $base_file: " . encode_json($base_record);
        }
        $base_by_id{$id} = $base_record;
    }

    for my $edited_record (@$edited_records) {
        my $id = $edited_record->{id};

        if (!$id) {
            push @new, $edited_record;
        }
        elsif (!$base_by_id{$id}) {
            die "$type record in $edited_file has id ($id) that doesn't correspond with a record in $base_file: " . $JSON->encode($edited_record);
        }
        else {
            my $base_record = delete $base_by_id{$id};
            next if is_deeply_equal($base_record, $edited_record);
            push @updated, [ $base_record => $edited_record ];
        }
    }

    for my $base_record (values %base_by_id) {
        push @deleted, $base_record;
    }

    return (\@new, \@updated, \@deleted);
}

sub is_deeply_equal {
    my ($left, $right) = @_;
    # use [] to avoid nonref issues without changing $JSON itself
    return $JSON->encode([$left]) eq $JSON->encode([$right]);
}

sub slurp_json {
    my $file = shift;
    local $/;
    open (my $f, '<', $file)
        or die "Cannot open initialdata file '$file' for read: $@";
    return $JSON->decode(scalar <$f>);
}
