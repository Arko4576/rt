#!@PERL@
# BEGIN BPS TAGGED BLOCK {{{
#
# COPYRIGHT:
#
# This software is Copyright (c) 1996-2017 Best Practical Solutions, LLC
#                                          <sales@bestpractical.com>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to Best Practical Solutions, LLC.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# Request Tracker, to Best Practical Solutions, LLC, you confirm that
# you are the copyright holder for those contributions and you grant
# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# END BPS TAGGED BLOCK }}}
use 5.010;
use strict;
use warnings;

# fix lib paths, some may be relative
BEGIN {
    require File::Spec;
    my @libs = ("@RT_LIB_PATH@", "@LOCAL_LIB_PATH@");
    my $bin_path;

    for my $lib (@libs) {
        unless ( File::Spec->file_name_is_absolute($lib) ) {
            unless ($bin_path) {
                if ( File::Spec->file_name_is_absolute(__FILE__) ) {
                    $bin_path = ( File::Spec->splitpath(__FILE__) )[1];
                }
                else {
                    require FindBin;
                    no warnings "once";
                    $bin_path = $FindBin::Bin;
                }
            }
            $lib = File::Spec->catfile( $bin_path, File::Spec->updir, $lib );
        }
        unshift @INC, $lib;
    }

}

use RT;
RT::LoadConfig();

use Getopt::Long;
use Pod::Usage qw//;
use List::MoreUtils 'uniq';
use JSON ();
my $JSON = JSON->new->canonical;

my %OPT;
GetOptions(
    \%OPT,
    "help|h",
    "quiet|q!",
    "log=s",
    "dryrun",

    "base=s",
    "edited=s",
    "merge-strategy=s",
);

exit Pod::Usage::pod2usage(-verbose => 1) if $OPT{help};

my $base_file = $OPT{base};
my $edited_file = $OPT{edited};

exit Pod::Usage::pod2usage unless $base_file && $edited_file;

my $merge_strategy = $OPT{'merge-strategy'};

die "Invalid value for --merge-strategy. Expected 'base', 'current', 'edited', or 'quit'."
    unless !$merge_strategy || $merge_strategy =~ /^(base|current|edited|quit)$/;

RT->Config->Set( LogToSTDERR => $OPT{log} ) if $OPT{log};

RT::Init();

my $dryrun = $OPT{'dryrun'};
RT->Logger->debug("dryrun enabled") if $dryrun;

my $base_records = slurp_json($base_file);
my $edited_records = slurp_json($edited_file);

my $export_options = delete $edited_records->{ExportOptions}
    or die "Required metadata ExportOptions not present in $edited_file. Did you pass --sync to rt-serializer?";
delete $base_records->{ExportOptions};

my @record_types = qw/Groups Users Members ACL Queues Classes
                      ScripActions ScripConditions Templates
                      CustomFields CustomRoles Scrips
                      Catalogs Assets Articles/;

my %class_type = (
    Members => 'GroupMembers',
);

my %new_for_insertdata;

for my $type (@record_types) {
    my ($new_records, $updated_records, $deleted_records) = find_differences(
        $base_records->{$type},
        $edited_records->{$type},
        $type,
    );

    next if !@$new_records
         && !@$updated_records
         && !@$deleted_records;

    RT->Logger->info("Merging changes from $type: " . scalar(@$new_records) . " new records, " . scalar(@$updated_records) . " updated, " . scalar(@$deleted_records) . " deleted");

    my $collection_class = "RT::" . ($class_type{$type} || $type);
    my $record_class = $collection_class->RecordClass;

    if ($dryrun) {
        RT->Logger->debug("Skipping create of " . scalar(@$new_records) . "x $type because of dry run.") if @$new_records;
    }
    else {
        $new_for_insertdata{$type} = $new_records;
    }

    for (@$updated_records) {
        my ($base, $edited) = @$_;
        my $id = $base->{id};
        my $record = $record_class->new(RT->SystemUser);
        $record->Load($id);
        if (!$record->Id) {
            RT->Logger->error("Unable to load $record_class $id for updating; skipping");
            next;
        }

        for my $column (uniq sort keys(%$base), keys(%$edited)) {
            my $base_value = $base->{$column} // "";
            my $edited_value = $edited->{$column} // "";

            for ($base_value, $edited_value) {
                $_ = !!$_ if JSON::is_bool($_)
            }

            next if is_deeply_equal($base_value, $edited_value);

            if (!ref($base_value) && !ref($edited_value)) {
                my $method = "Set$column";
                if ($record->can($method) || $record->_Accessible($column, 'write')) {
                    my $current_value = $record->$column // "";

                    # skip if it was already updated outside initialdata
                    next if $current_value eq $edited_value;

                    my $new_value = $edited_value;

                    if ($base_value ne $current_value) {
                        my $decision = decide_merge(
                            base_record    => $base,
                            edited_record  => $edited,
                            current_record => $record,
                            column         => $column,
                            base_value     => $base_value,
                            edited_value   => $edited_value,
                            current_value  => $current_value,
                        );
                        if ($decision eq 'base') {
                            $new_value = $base_value;
                        }
                        elsif ($decision eq 'edited') {
                            # continue
                        }
                        elsif ($decision eq 'current') {
                            next;
                        }
                    }

                    if ($dryrun) {
                        RT->Logger->debug("Skipping update $record_class #$id $column from '$current_value' to '$new_value' because of dry run.");
                        next;
                    }

                    my ($ok, $msg) = $record->$method($new_value);
                    if ($ok) {
                        RT->Logger->debug("Updated $record_class #$id $column: $msg");
                    }
                    else {
                        RT->Logger->error("Unable to update $record_class #$id $column: $msg");
                    }
                }
                else {
                    die "Unable to handle updating $record_class $column (no method)";
                }
            }
            else {
                die "Unable to handle updating $record_class $column (composite value)";
            }
        }
    }

    for my $deleted (@$deleted_records) {
        my $id = $deleted->{id};
        my $record = $record_class->new(RT->SystemUser);
        $record->Load($id);

        my ($ok, $msg);
        if ($record->can('SetDisabled') || $record->_Accessible('Disabled', 'write')) {
            if ($dryrun) {
                RT->Logger->debug("Skipping disabling of $record_class #$id because of dry run.");
                next;
            }
            ($ok, $msg) = $record->SetDisabled(1);
        }
        elsif ($record->can('Delete')) {
            if ($dryrun) {
                RT->Logger->debug("Skipping delete of $record_class #$id because of dry run.");
                next;
            }
            ($ok, $msg) = $record->Delete;
        }
        else {
            die "No method to delete $record_class #$id";
        }

        if ($ok) {
            RT->Logger->debug("Deleted $record_class #$id: $msg");
        }
        else {
            RT->Logger->error("Unable to delete $record_class #$id: $msg");
        }
    }
}

if (grep { scalar(@$_) } values %new_for_insertdata) {
    my $new_json = $JSON->encode(\%new_for_insertdata);
    $RT::Handle->InsertData(\$new_json, undef, disconnect_after => 0);
}

sub find_differences {
    my $base_records = shift;
    my $edited_records = shift;
    my $type = shift;

    my (@new, @deleted, @updated);
    my (%base_by_id, %edited_by_id);

    for my $base_record (@$base_records) {
        my $id = $base_record->{id};

        if (!$id) {
            die "Missing id for this $type record in $base_file: " . encode_json($base_record);
        }
        $base_by_id{$id} = $base_record;
    }

    for my $edited_record (@$edited_records) {
        my $id = $edited_record->{id};

        if (!$id) {
            push @new, $edited_record;
        }
        elsif (!$base_by_id{$id}) {
            die "$type record in $edited_file has id ($id) that doesn't correspond with a record in $base_file: " . $JSON->encode($edited_record);
        }
        else {
            my $base_record = delete $base_by_id{$id};
            next if is_deeply_equal($base_record, $edited_record);
            push @updated, [ $base_record => $edited_record ];
        }
    }

    for my $base_record (values %base_by_id) {
        push @deleted, $base_record;
    }

    return (\@new, \@updated, \@deleted);
}

sub is_deeply_equal {
    my ($left, $right) = @_;
    # use [] to avoid nonref issues without changing $JSON itself
    return $JSON->encode([$left]) eq $JSON->encode([$right]);
}

sub slurp_json {
    my $file = shift;
    local $/;
    open (my $f, '<', $file)
        or die "Cannot open initialdata file '$file' for read: $@";
    return $JSON->decode(scalar <$f>);
}

sub decide_merge {
    my %args = (
        base_record    => undef,
        edited_record  => undef,
        current_record => undef,
        column         => undef,
        base_value     => undef,
        edited_value   => undef,
        current_value  => undef,
        @_,
    );

    my $record = $args{current_record};
    my $id = $record->id;
    my $type = ref($record);
    $type =~ s/^RT:://;

    local $| = 1;
    while (1) {
        unless ($OPT{quiet} && $merge_strategy) {
            print "\n";
            print "Conflict resolution required for $type #$id $args{column}:\n";
            print "    Base value:     $args{base_value}\n";
            print "    Edited value:   $args{edited_value}\n";
            print "    Database value: $args{current_value}\n";
        }

        if ($merge_strategy) {
            print "Using specified merge strategy '$merge_strategy'.\n" unless $OPT{quiet};
            exit if $merge_strategy eq 'quit';
            return $merge_strategy;
        }

        print "Would you like to (q)uit, (s)ee more context, or set value to (b)ase, (e)dited, or (d)atabase? ";

        my $answer = (scalar <STDIN>) // "";
        print "\n";

        exit 1 if $answer =~ /^q/i;
        return "base" if $answer =~ /^b/i;
        return "edited" if $answer =~ /^e/i;
        return "current" if $answer =~ /^d/i;

        if ($answer =~ /^s/i) {
            my %values = %{ $record->{values} };
            delete $values{$_} for grep { ($values{$_}//"") eq ""} keys %values;
            for ('base', 'edited', ['current', \%values]) {
                my ($key, $record) = ref($_)
                                   ? @$_
                                   : ($_, $args{$_ . '_record'});
                print "\u$key:\n";
                print "    $_\n"
                    for split /\n/, JSON->new->pretty->canonical->encode($record);
            }
        }
    }
}

=head1 NAME

rt-merge-initialdata - Merge changes from an edited initialdata

=head1 SYNOPSIS

    rt-merge-initialdata --base initialdata.json --edited updated.json


This tool allows you to edit a JSON-based initialdata file and merge
those changes into your RT instance. The intended workflow is you first
create an initialdata from your running RT config with:

    sbin/rt-serializer --sync --format JSON

Then, copy the resulting C<initialdata.json> into a new file. Edit that
C<updated.json> to create, update, and delete records (see below for
considerations).

Then run F<rt-merge-initialdata> like so:

    rt-merge-initialdata --base initialdata.json --edited updated.json

F<rt-merge-initialdata> will update any records that you edited, create
any records you added, and disable (or delete) any records you removed.
Note that the C<id> field is used to track identity across the base,
edited, and database versions of the same record, so take care when
dealing with it. (Any record without an C<id> is treated as a new one to
be created, and any record in the base which does not have a
corresponding C<id> in the edited file will be disabled/deleted).

Any changes made in the database after the base was exported will be
untouched by F<rt-merge-initialdata>. If it turns out that a field was
changed in both the edited initialdata I<and> the database, then a
conflict will be presented to you with a prompt asking which version to
keep. The C<--merge-strategy> flag lets you decide in advance to handle
all such conflicts using a consistent strategy, to avoid prompting.

=head2 OPTIONS

=over

=item B<--base> I<filename>

The filename of the "base" initialdata. This should be a pristine initialdata
file exported by F<sbin/rt-serializer>.

=item B<--edited> I<filename>

The filename of the "edited" initialdata. This should be a copy of the
filename provided to C<--base> with your edits made to it.

=item B<--merge-strategy> I<strategy>

Automatically resolve all conflicts without prompting the user. The
following merge strategies are available:

=over 4

=item C<edited>

Take the edits as specified in the edited initialdata, overwriting the
change made in the database after the base was exported.

=item C<current>

Keep the database's current value, ignoring the change made in the
edited initialdata.

=item C<base>

Revert to the base initialdata's value, rolling back the change made in
the database and ignoring the change made in the edited initialdata.

=item C<quit>

Abort processing at the first conflict. Note that this will likely
result in a subset of the edits being applied to your database.

=back

=item B<--quiet>

Avoid nonessential output.

=item B<--log> I<level>

Adjust LogToSTDERR config option.

=item B<--dryrun>

Attempt to process changes but skip making any actual changes to the
database. Changes that would have been made are logged at level C<debug>
so you may wish to pass C<--log=debug> to see them.

=back

=cut
